/**
 * @file src/gfmParser.c
 * 
 * Generic parser for files generated by the tiled plugin
 */
#include <GFraMe/gframe.h>
#include <GFraMe/gfmAssert.h>
#include <GFraMe/gfmError.h>
#include <GFraMe/core/gfmFile_bkend.h>
#include <GFraMe/gfmLog.h>
#include <GFraMe/gfmParser.h>
#include <GFraMe_int/gfmParserCommon.h>

#include <stdlib.h>
#include <string.h>

struct stGFMParsedObject {
    /** Type of the object */
    gfmParserType type;
    /** Object's horizontal position (when applied) */
    int x;
    /** Object's vertical position (when applied) */
    int y;
    /** Object's width (when applied) */
    int width;
    /** Object's height (when applied) */
    int height;
    /** Object's array of integer (when applied) */
    int *piBuf;
    /** Length of the parsed array (when applied) */
    int iLen;
    /** Array with all properties key, value pair */
    char **ppProperties;
    /** Number of properties parsed into this object */
    int propertiesLen;
};
typedef struct stGFMParsedObject gfmParsedObject;

/** The gfmParser struct */
struct stGFMParser {
    /** Currently opened file */
    gfmFile *pFile;
    /** Logger obtained when opening the file (on gfmParser_init) */
    gfmLog *pLog;
    /** The parsed object */
    gfmParsedObject object;
    /** Buffer used to read a string from the file (NULL-terminated) */
    char *pReadBuf;
    /** Total length of the 'pReadBuf' buffer */
    int readBufLen;
    /** Buffer used to stored all properties (keys and values), so they can be
     * easily indexed/pointed to on ppProps */
    char *pPropsBuf;
    /** Total length of the 'pPropsBuf' buffer */
    int propsBufLen;
    /** Array for easily pointing to all of a objects properties */
    char **ppProps;
    /** Total length of the 'ppProps' buffer */
    int propsLen;
};

/******************************************************************************/
/*                                                                            */
/* Static functions                                                           */
/*                                                                            */
/******************************************************************************/

/******************************************************************************/
/*                                                                            */
/* Public functions                                                           */
/*                                                                            */
/******************************************************************************/

/**
 * Alloc a new parser
 * 
 * @param  ppCtx The parser
 * @return       GFMRV_OK, GFMRV_ARGUMENTS_BAD, GFMRV_ALLOC_FAILED
 */
gfmRV gfmParser_getNew(gfmParser **ppCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(ppCtx, GFMRV_ARGUMENTS_BAD);
    ASSERT(!(*ppCtx), GFMRV_ARGUMENTS_BAD);
    
    // Alloc the struct
    *ppCtx = (gfmParser*)malloc(sizeof(gfmParser));
    ASSERT(*ppCtx, GFMRV_ALLOC_FAILED);
    // Clean it
    memset(*ppCtx, 0x0, sizeof(gfmParser));
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Close the file, clean any resources and free the parser
 * 
 * @param  ppCtx The parser
 * @return       GFMRV_OK, GFMRV_ARGUMENTS_BAD
 */
gfmRV gfmParser_free(gfmParser **ppCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(ppCtx, GFMRV_ARGUMENTS_BAD);
    ASSERT(*ppCtx, GFMRV_ARGUMENTS_BAD);
    
    // Make sure all resources are deallocated
    gfmParser_clean(*ppCtx);
    // Dealloc the struct
    free(*ppCtx);
    *ppCtx = 0;
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Initialize a parser and open its file
 * 
 * @param  pParser     The parser
 * @param  pCtx        The game's context
 * @param  pFilename   File to be parsed (must be on assets folder)
 * @param  filenameLen Length of the file's path
 * @return             GFMRV_OK, GFMRV_ARGUMENTS_BAD,
 *                     GFMRV_PARSER_ALREADY_INITIALIZED, ...
 */
gfmRV gfmParser_init(gfmParser *pParser, gfmCtx *pCtx, char *pFilename,
        int filenameLen) {
    gfmRV isFileOpen;
    gfmLog *pLog;
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    // Retrieve the logger
    rv = gfm_getLogger(&pLog, pCtx);
    ASSERT(rv == GFMRV_OK, rv);
    // Continue to sanitize arguments
    ASSERT_LOG(pParser, GFMRV_ARGUMENTS_BAD, pLog);
    ASSERT_LOG(pFilename, GFMRV_ARGUMENTS_BAD, pLog);
    ASSERT_LOG(filenameLen > 0, GFMRV_ARGUMENTS_BAD, pLog);
    // Check that there's no previous file open
    isFileOpen = gfmFile_isOpen(pParser->pFile);
    ASSERT_LOG(pParser->pFile == 0 || isFileOpen == GFMRV_FALSE,
            GFMRV_PARSER_ALREADY_INITIALIZED, pLog);
    
    // Clean the parsed object
    memset(&(pParser->object), 0x0, sizeof(gfmParsedObject));
    // Open the file
    if (!(pParser->pFile)) {
        rv = gfmFile_getNew(&(pParser->pFile));
        ASSERT_LOG(rv == GFMRV_OK, rv, pLog);
    }
    rv = gfmFile_openAsset(pParser->pFile, pCtx, pFilename, filenameLen, 1/*isText*/);
    ASSERT_LOG(rv == GFMRV_OK, rv, pLog);
    
    // Store the logger
    pParser->pLog = pLog;
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Close the file but keep allocated resources, so the parser may be reused
 * 
 * @param  pCtx The parser
 * @return      GFMRV_OK, GFMRV_ARGUMENTS_BAD
 */
gfmRV gfmParser_reset(gfmParser *pCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    
    // It will return true only if there's a file and its open, so that's safe
    if (gfmFile_isOpen(pParser->pFile) == GFMRV_TRUE) {
        rv = gfmFile_close(pCtx->pFile);
        ASSERT_LOG(rv == GFMRV_OK, rv, pCtx->pLog);
    }
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Clean all allocated resources and close any open file
 * 
 * @param  pCtx The parser
 * @return      GFMRV_OK, GFMRV_ARGUMENTS_BAD
 */
gfmRV gfmParser_clean(gfmParser *pCtx);

/**
 * Parse the next object
 * 
 * @param  pCtx The parser
 * @return      GFMRV_OK, GFMRV_ARGUMENTS_BAD, GFMRV_PARSER_NOT_INITIALIZED,
 *              GFMRV_PARSER_FINISHED, GFMRV_ALLOC_FAILED,
 *              GFMRV_PARSER_BAD_TOKEN
 */
gfmRV gfmParser_parseNext(gfmParser *pCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    // Check that it was initialized
    ASSERT(pCtx->pFile, GFMRV_PARSER_NOT_INITIALIZED);
    // Continue to sanitize arguments
    ASSERT_LOG(gfmFile_isOpen(pParser->pFile) == GFMRV_TRUE,
            GFMRV_PARSER_NOT_INITIALIZED, pCtx->pLog);
    
    // TODO Try to parse its type
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Retrieve the parsed object's type
 * 
 * @param  pType The object's type
 * @param  pCtx  The parser
 * @return       GFMRV_OK, GFMRV_ARGUMENTS_BAD, GFMRV_PARSER_NOT_INITIALIZED,
 *               GFMRV_PARSER_NO_OBJECT
 */
gfmRV gfmParser_getType(gfmParserType *pType, gfmParser *pCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    // Check that it was initialized
    ASSERT(pCtx->pFile, GFMRV_PARSER_NOT_INITIALIZED);
    // Continue to sanitize arguments
    ASSERT_LOG(pType, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    // Check that an object was parsed
    ASSERT_LOG(pCtx->object.type != gfmParserType_none, GFMRV_PARSER_NO_OBJECT,
            pCtx->pLog);
    
    // Get the attribute
    *pType = pCtx->object.type;
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Retrieve the parsed object's position
 * 
 * @param  pX   The object's horizontal position
 * @param  pY   The object's vertical position
 * @param  pCtx The parser
 * @return      GFMRV_OK, GFMRV_ARGUMENTS_BAD, GFMRV_PARSER_NOT_INITIALIZED,
 *              GFMRV_PARSER_NO_OBJECT, GFMRV_PARSER_INVALID_FIELD
 */
gfmRV gfmParser_getPos(int *pX, int *pY, gfmParser *pCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    // Check that it was initialized
    ASSERT(pCtx->pFile, GFMRV_PARSER_NOT_INITIALIZED);
    // Continue to sanitize arguments
    ASSERT_LOG(pX, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    ASSERT_LOG(pY, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    // Check that an object was parsed
    ASSERT_LOG(pCtx->object.type != gfmParserType_none, GFMRV_PARSER_NO_OBJECT,
            pCtx->pLog);
    
    // TODO Check if the type has this attribute
    // Get the attribute
    *pX = pCtx->object.x;
    *pY = pCtx->object.y;
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Retrieve the parsed object's dimensions
 * 
 * @param  pWidth  The object's width
 * @param  pHeight The object's height
 * @param  pCtx    The parser
 * @return         GFMRV_OK, GFMRV_ARGUMENTS_BAD, GFMRV_PARSER_NOT_INITIALIZED,
 *                 GFMRV_PARSER_NO_OBJECT, GFMRV_PARSER_INVALID_FIELD
 */
gfmRV gfmParser_getDimensions(int *pWidth, int *pHeight, gfmParser *pCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    // Check that it was initialized
    ASSERT(pCtx->pFile, GFMRV_PARSER_NOT_INITIALIZED);
    // Continue to sanitize arguments
    ASSERT_LOG(pWidth, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    ASSERT_LOG(pHeight, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    // Check that an object was parsed
    ASSERT_LOG(pCtx->object.type != gfmParserType_none, GFMRV_PARSER_NO_OBJECT,
            pCtx->pLog);
    
    // TODO Check if the type has this attribute
    // Get the attribute
    *pWidth = pCtx->object.width
    *pHeight = pCtx->object.height
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Retrieve the parsed object's array of integers (only used for tilemaps)
 * 
 * @param  ppBuffer The retrieved array (it's volatile, so it must be copied)
 * @param  pLen     How many integers there are in the array
 * @param  pCtx     The parser
 * @return          GFMRV_OK, GFMRV_ARGUMENTS_BAD, GFMRV_PARSER_NOT_INITIALIZED,
 *                  GFMRV_PARSER_NO_OBJECT, GFMRV_PARSER_INVALID_FIELD
 */
gfmRV gfmParser_getIntArray(int **ppBuffer, int *pLen, gfmParser *pCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    // Check that it was initialized
    ASSERT(pCtx->pFile, GFMRV_PARSER_NOT_INITIALIZED);
    // Continue to sanitize arguments
    ASSERT_LOG(ppBuffer, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    ASSERT_LOG(pLen, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    // Check that an object was parsed
    ASSERT_LOG(pCtx->object.type != gfmParserType_none, GFMRV_PARSER_NO_OBJECT,
            pCtx->pLog);
    
    // TODO Check if the type has this attribute
    // Get the attribute
    *ppBufer = pCtx->object.piBuf;
    *pLen = pCtx->object.iLen;
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Retrieve the parsed object's 
 * 
 * @param  pNum How many properties the object has
 * @param  pCtx The parser
 * @return      GFMRV_OK, GFMRV_ARGUMENTS_BAD, GFMRV_PARSER_NOT_INITIALIZED,
 *              GFMRV_PARSER_NO_OBJECT
 */
gfmRV gfmParser_getNumProperties(int *pNum, gfmParser *pCtx) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    // Check that it was initialized
    ASSERT(pCtx->pFile, GFMRV_PARSER_NOT_INITIALIZED);
    // Continue to sanitize arguments
    ASSERT_LOG(pNum, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    // Check that an object was parsed
    ASSERT_LOG(pCtx->object.type != gfmParserType_none, GFMRV_PARSER_NO_OBJECT,
            pCtx->pLog);
    
    // TODO Check if the type has this attribute
    // Get the attribute
    *pNum = propertiesLen;
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

/**
 * Retrieve the parsed object's 
 * 
 * @param  ppKey The property's key (a NULL-terminated string)
 * @param  pVal  The property's value (a NULL-terminated string)
 * @param  pCtx  The parser
 * @param  index The index of the property
 * @return       GFMRV_OK, GFMRV_ARGUMENTS_BAD, GFMRV_PARSER_NOT_INITIALIZED,
 *               GFMRV_PARSER_NO_OBJECT, GFMRV_PARSER_INVALID_FIELD,
 *               GFMRV_INVALID_INDEX
 */
gfmRV gfmParser_getProperty(char **ppKey, int *pVal, gfmParser *pCtx,
        int index) {
    gfmRV rv;
    
    // Sanitize arguments
    ASSERT(pCtx, GFMRV_ARGUMENTS_BAD);
    // Check that it was initialized
    ASSERT(pCtx->pFile, GFMRV_PARSER_NOT_INITIALIZED);
    // Continue to sanitize arguments
    ASSERT_LOG(ppKey, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    ASSERT_LOG(pVal, GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    // Check that an object was parsed
    ASSERT_LOG(pCtx->object.type != gfmParserType_none, GFMRV_PARSER_NO_OBJECT,
            pCtx->pLog);
    
    // TODO Check if the type has this attribute
    // Check if the index is valid
    ASSERT_LOG(index > 0 && index < pCtx->object.propertiesLen,
            GFMRV_ARGUMENTS_BAD, pCtx->pLog);
    // Get the attribute
    *ppKey = pCtx->object.ppProperties[index * 2];
    *pVal = pCtx->object.ppProperties[index * 2 + 1];
    
    rv = GFMRV_OK;
__ret:
    return rv;
}

